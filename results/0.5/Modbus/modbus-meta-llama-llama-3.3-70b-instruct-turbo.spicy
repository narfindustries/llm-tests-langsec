# Zeek Spicy specification for Modbus protocol

@ifdef::.spicyModeratelyStrict

module Modbus;

fetch-client Modbus::Client {
    conn: Modbus::Connection,
    message: Modbus::Message,
    is_orig: bool,
};

fetch-server Modbus::Server {
    conn: Modbus::Connection,
    message: Modbus::Message,
    is_orig: bool,
};

type Modbus::Connection = record {
    addr: addr,
    port: port,
    transport: transport,
};

type Modbus::Message = record {
    transaction_id: uint16,
    protocol_id: uint16,
    length: uint16,
    unit_id: uint8,
    function_code: uint8,
    data: bytestring,
};

# Standard Modbus Function Codes
const ReadCoils                    : uint8 = 0x01;
const ReadDiscreteInputs           : uint8 = 0x02;
const ReadHoldingRegisters         : uint8 = 0x03;
const ReadInputRegisters           : uint8 = 0x04;
const WriteSingleCoil              : uint8 = 0x05;
const WriteSingleRegister          : uint8 = 0x06;
const ReadExceptionStatus          : uint8 = 0x07;
const.Diagnostics                  : uint8 = 0x08;
const Program                      : uint8 = 0x10;
const Poll                         : uint8 = 0x11;
const SendAwake                    : uint8 = 0x12;
const imgUrl                       : uint8 = 0x2B;

# skip reserved function codes 0x52-0x5F

# skip reserved function codes 0xE0-0xE4

# skip reserved function codes 0xE6-0xE9

# skip reserved function codes 0xF2


# Enum value for function code
const FunctionCode: enum {
    FC_ReadCoils = ReadCoils,
    FC_ReadDiscreteInputs = ReadDiscreteInputs,
    FC_ReadHoldingRegisters = ReadHoldingRegisters,
    FC_ReadInputRegisters = ReadInputRegisters,
    FC_WriteSingleCoil = WriteSingleCoil,
    FC_WriteSingleRegister = WriteSingleRegister,
    FC_ReadExceptionStatus = ReadExceptionStatus,
    FC_Diagnostics = .Diagnostics,
    FC_Program = Program,
    FC_Poll = Poll,
    FC_SendAwake = SendAwake,
    FC_imgUrl = imgUrl,
};

event zeek::zeek_init() {
    Modbus::register_protocol(Modbus::Client);
    Modbus::register_protocol(Modbus::Server);
}

event connection_established(c: connection) {
    if (c$id$resp_p == 170) {
        # TCP connection, handle as Modbus over TCP
        Modbus::start_protocol(Modbus::Client, c);
    } else if (c$id$resp_p == 0/udp) {
        # UDP connection, handle as Modbus over UDP
        Modbus::start_protocol(Modbus::Server, c);
    }
}

event zeek_done() {
    print("Modbus Spicy protocol finished");
}
