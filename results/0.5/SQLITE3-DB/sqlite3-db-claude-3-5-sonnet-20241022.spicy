module SQLITE3-DB;

public type Header = unit {
    magic: bytes &size=16;
    page_size: uint16;
    write_version: uint8;
    read_version: uint8;
    reserved_space: uint8;
    max_payload_fraction: uint8;
    min_payload_fraction: uint8;
    leaf_payload_fraction: uint8;
    file_change_counter: uint32;
    database_size: uint32;
    first_freelist_trunk: uint32;
    freelist_pages: uint32;
    schema_cookie: uint32;
    schema_format: uint32;
    default_page_cache_size: uint32;
    largest_root_btree: uint32;
    text_encoding: uint32;
    user_version: uint32;
    vacuum_mode: uint32;
    application_id: uint32;
    version_valid_for: uint32;
    sqlite_version: uint32;

    on %done {
        print self;
    }
};

public type Record = unit {
    record_type: uint8;
    payload_length: uint16;
    rowid: uint32;
    data: bytes &size=self.payload_length;

    on %done {
        print self;
    }
};

type Page = unit {
    header: Header;
    records: Record[];
};

public type Database = unit {
    pages: Page[];
};

on SQLITE3-DB::Header -> event SQLITE3-DB::header(
    self.magic,
    self.page_size,
    self.write_version,
    self.read_version,
    self.reserved_space,
    self.max_payload_fraction,
    self.min_payload_fraction,
    self.leaf_payload_fraction,
    self.file_change_counter,
    self.database_size,
    self.first_freelist_trunk,
    self.freelist_pages,
    self.schema_cookie,
    self.schema_format,
    self.default_page_cache_size,
    self.largest_root_btree,
    self.text_encoding,
    self.user_version,
    self.vacuum_mode,
    self.application_id,
    self.version_valid_for,
    self.sqlite_version
);

on SQLITE3-DB::Record -> event SQLITE3-DB::record(
    self.record_type,
    self.payload_length,
    self.rowid,
    self.data
);