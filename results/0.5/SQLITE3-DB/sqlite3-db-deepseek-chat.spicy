module SQLITE3_DB;

import spicy;

type Magic = bytes &size=16 &convert="SQLite format 3\0";

type Header = unit {
    magic: Magic;
    page_size: uint16 &convert=bytes_to_uint16;
    write_version: uint8;
    read_version: uint8;
    reserved: uint8 &size=1;
    max_embedded_payload_fraction: uint8;
    min_embedded_payload_fraction: uint8;
    leaf_payload_fraction: uint8;
    file_change_counter: uint32 &convert=bytes_to_uint32;
    database_size_in_pages: uint32 &convert=bytes_to_uint32;
    first_freelist_page: uint32 &convert=bytes_to_uint32;
    number_of_freelist_pages: uint32 &convert=bytes_to_uint32;
    schema_cookie: uint32 &convert=bytes_to_uint32;
    schema_format: uint32 &convert=bytes_to_uint32;
    default_page_cache_size: uint32 &convert=bytes_to_uint32;
    largest_root_btree_page: uint32 &convert=bytes_to_uint32;
    text_encoding: uint32 &convert=bytes_to_uint32;
    user_version: uint32 &convert=bytes_to_uint32;
    incremental_vacuum_mode: uint32 &convert=bytes_to_uint32;
    application_id: uint32 &convert=bytes_to_uint32;
    version_valid_for: uint32 &convert=bytes_to_uint32;
    sqlite_version_number: uint32 &convert=bytes_to_uint32;
};

type Page = unit {
    header: Header;
};

type SQLite3_DB = unit {
    pages: Page[] &size=100;
};

on SQLite3_DB::%init {
    self.pages = [];
}

on SQLite3_DB::%done {
    print "SQLite3 DB parsing completed.";
}

function bytes_to_uint16(b: bytes): uint16 {
    return b[0] | (b[1] << 8);
}

function bytes_to_uint32(b: bytes): uint32 {
    return b[0] | (b[1] << 8) | (b[2] << 16) | (b[3] << 24);
}