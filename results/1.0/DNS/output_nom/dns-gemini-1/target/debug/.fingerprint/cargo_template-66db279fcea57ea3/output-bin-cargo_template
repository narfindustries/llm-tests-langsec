{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0283","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0283\nlet x = \"hello\".chars().rev().collect();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nA common example is the `collect` method on `Iterator`. It has a generic type\nparameter with a `FromIterator` bound, which for a `char` iterator is\nimplemented by `Vec` and `String` among others. Consider the following snippet\nthat reverses the characters of a string:\n\nIn the first code example, the compiler cannot infer what the type of `x` should\nbe: `Vec<char>` and `String` are both suitable candidates. To specify which type\nto use, you can use a type annotation on `x`:\n\n```\nlet x: Vec<char> = \"hello\".chars().rev().collect();\n```\n\nIt is not necessary to annotate the full type. Once the ambiguity is resolved,\nthe compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nWe can see a self-contained example below:\n\n```compile_fail,E0283\nstruct Foo;\n\nimpl Into<u32> for Foo {\n    fn into(self) -> u32 { 1 }\n}\n\nlet foo = Foo;\nlet bar: u32 = foo.into() * 1u32;\n```\n\nThis error can be solved by adding type annotations that provide the missing\ninformation to the compiler. In this case, the solution is to specify the\ntrait's type parameter:\n\n```\nstruct Foo;\n\nimpl Into<u32> for Foo {\n    fn into(self) -> u32 { 1 }\n}\n\nlet foo = Foo;\nlet bar: u32 = Into::<u32>::into(foo) * 1u32;\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":3131,"byte_end":3139,"line_start":127,"line_end":127,"column_start":22,"column_end":30,"is_primary":false,"text":[{"text":"            let ip = Ipv6Addr::from(bytes.try_into().unwrap());","highlight_start":22,"highlight_end":30}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":3152,"byte_end":3160,"line_start":127,"line_end":127,"column_start":43,"column_end":51,"is_primary":true,"text":[{"text":"            let ip = Ipv6Addr::from(bytes.try_into().unwrap());","highlight_start":43,"highlight_end":51}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"multiple `impl`s satisfying `Ipv6Addr: From<_>` found in the `core` crate:\n- impl From<[u16; 8]> for Ipv6Addr;\n- impl From<[u8; 16]> for Ipv6Addr;\n- impl From<u128> for Ipv6Addr;\n- impl<T> From<T> for T;","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"try using a fully qualified path to specify the expected types","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":3146,"byte_end":3146,"line_start":127,"line_end":127,"column_start":37,"column_end":37,"is_primary":true,"text":[{"text":"            let ip = Ipv6Addr::from(bytes.try_into().unwrap());","highlight_start":37,"highlight_end":37}],"label":null,"suggested_replacement":"<&[u8] as TryInto<T>>::try_into(","suggestion_applicability":"HasPlaceholders","expansion":null},{"file_name":"src/main.rs","byte_start":3151,"byte_end":3162,"line_start":127,"line_end":127,"column_start":42,"column_end":53,"is_primary":true,"text":[{"text":"            let ip = Ipv6Addr::from(bytes.try_into().unwrap());","highlight_start":42,"highlight_end":53}],"label":null,"suggested_replacement":")","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0283]\u001b[0m\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:127:43\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m127\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            let ip = Ipv6Addr::from(bytes.try_into().unwrap());\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mtype must be known at this point\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: multiple `impl`s satisfying `Ipv6Addr: From<_>` found in the `core` crate:\u001b[0m\n\u001b[0m            - impl From<[u16; 8]> for Ipv6Addr;\u001b[0m\n\u001b[0m            - impl From<[u8; 16]> for Ipv6Addr;\u001b[0m\n\u001b[0m            - impl From<u128> for Ipv6Addr;\u001b[0m\n\u001b[0m            - impl<T> From<T> for T;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: try using a fully qualified path to specify the expected types\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m127\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            let ip = Ipv6Addr::from(\u001b[0m\u001b[0m\u001b[38;5;10m<&[u8] as TryInto<T>>::try_into(\u001b[0m\u001b[0mbytes\u001b[0m\u001b[0m\u001b[38;5;10m)\u001b[0m\u001b[0m.unwrap());\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                     \u001b[0m\u001b[0m\u001b[38;5;10m++++++++++++++++++++++++++++++++\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[38;5;10m~\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 1 previous error","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to 1 previous error\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"For more information about this error, try `rustc --explain E0283`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about this error, try `rustc --explain E0283`.\u001b[0m\n"}
