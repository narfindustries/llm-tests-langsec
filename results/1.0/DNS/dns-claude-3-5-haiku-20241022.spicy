module DNS;

import spicy;

public type Message = unit {
    header: Header;
    questions: list<Question> &length(header.qdcount);
    answers: list<ResourceRecord> &length(header.ancount);
    authority: list<ResourceRecord> &length(header.nscount);
    additional: list<ResourceRecord> &length(header.arcount);

    on %done {
        // Optional post-processing or validation
    }
};

type Header = unit {
    id: uint16;
    flags: Flags;
    qdcount: uint16;
    ancount: uint16;
    nscount: uint16;
    arcount: uint16;
};

type Flags = unit {
    data: uint16;

    qr:     bool = data[15:1];   # Query/Response
    opcode: uint8 = data[14:4];  # Operation Code
    aa:     bool = data[10:1];   # Authoritative Answer
    tc:     bool = data[9:1];    # Truncation
    rd:     bool = data[8:1];    # Recursion Desired
    ra:     bool = data[7:1];    # Recursion Available
    z:      uint8 = data[6:3];   # Reserved
    rcode:  uint8 = data[3:4];   # Response Code
};

type Question = unit {
    name: DNS::DomainName;
    qtype: uint16;
    qclass: uint16;
};

type ResourceRecord = unit {
    name: DNS::DomainName;
    type: uint16;
    class_: uint16;
    ttl: uint32;
    rdlength: uint16;
    rdata: bytes &length=rdlength;
};

type DomainName = unit {
    labels: list<Label> { 
        local continue = true;
        while ( continue ) {
            local label = Label();
            if ( label.length == 0 ) {
                continue = false;
            }
        }
    }

    type Label = unit {
        length: uint8;
        if ( length > 0 && length < 64 ) {
            name: bytes &length=length;
        }
        else if ( length >= 192 ) {
            # Handle DNS name compression
            offset: uint16 &parse_at=(length & 0x3f) * 256 + input.read(1);
        }
    }
};