module SQLITE3-DB;

public type Header = unit {
    magic: bytes &size=16;
    page_size: uint16;
    write_version: uint8;
    read_version: uint8;
    reserved_bytes: uint8;
    max_payload_fraction: uint8;
    min_payload_fraction: uint8;
    leaf_payload_fraction: uint8;
    file_change_counter: uint32;
    database_size: uint32;
    first_freelist_trunk: uint32;
    total_freelist_pages: uint32;
    schema_cookie: uint32;
    schema_format: uint32;
    default_page_cache_size: uint32;
    largest_root_btree: uint32;
    text_encoding: uint32;
    user_version: uint32;
    incremental_vacuum: uint32;
    application_id: uint32;
    reserved: bytes &size=20;
    version_valid: uint32;
    version: uint32;

    on %done {
        if ( self.magic != b"SQLite format 3\x00" ) {
            print "Invalid SQLite magic header";
            return;
        }
    }
};

public type Record = unit {
    type: uint8;
    payload: bytes &eod;
};

public type Page = unit {
    header: uint8;
    cells: uint16;
    content: bytes &eod;
};

public type Database = unit {
    header: Header;
    pages: Page[];
};

on Database::header -> event SQLITE3::header(
    $magic: bytes,
    $page_size: uint16,
    $write_version: uint8,
    $read_version: uint8
);

on Page -> event SQLITE3::page(
    $header: uint8,
    $cells: uint16
);

on Record -> event SQLITE3::record(
    $type: uint8,
    $payload: bytes
);