{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0283","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0283\nlet x = \"hello\".chars().rev().collect();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nA common example is the `collect` method on `Iterator`. It has a generic type\nparameter with a `FromIterator` bound, which for a `char` iterator is\nimplemented by `Vec` and `String` among others. Consider the following snippet\nthat reverses the characters of a string:\n\nIn the first code example, the compiler cannot infer what the type of `x` should\nbe: `Vec<char>` and `String` are both suitable candidates. To specify which type\nto use, you can use a type annotation on `x`:\n\n```\nlet x: Vec<char> = \"hello\".chars().rev().collect();\n```\n\nIt is not necessary to annotate the full type. Once the ambiguity is resolved,\nthe compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nWe can see a self-contained example below:\n\n```compile_fail,E0283\nstruct Foo;\n\nimpl Into<u32> for Foo {\n    fn into(self) -> u32 { 1 }\n}\n\nlet foo = Foo;\nlet bar: u32 = foo.into() * 1u32;\n```\n\nThis error can be solved by adding type annotations that provide the missing\ninformation to the compiler. In this case, the solution is to specify the\ntrait's type parameter:\n\n```\nstruct Foo;\n\nimpl Into<u32> for Foo {\n    fn into(self) -> u32 { 1 }\n}\n\nlet foo = Foo;\nlet bar: u32 = Into::<u32>::into(foo) * 1u32;\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":2705,"byte_end":2713,"line_start":116,"line_end":116,"column_start":15,"column_end":23,"is_primary":true,"text":[{"text":"        bytes.try_into().map(Ipv6Addr::from).map(Rdata::AAAA)","highlight_start":15,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"multiple `impl`s satisfying `_: TryFrom<&[u8]>` found in the `core` crate:\n- impl<'a, T, N> TryFrom<&'a [T]> for &'a [T; N]\n  where the constant `N` has type `usize`;\n- impl<T, N> TryFrom<&[T]> for Simd<T, N>\n  where the constant `N` has type `usize`, LaneCount<N>: SupportedLaneCount, T: SimdElement;\n- impl<T, N> TryFrom<&[T]> for [T; N]\n  where the constant `N` has type `usize`, T: Copy;\n- impl<T, U> TryFrom<U> for T\n  where U: std::convert::Into<T>;","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `&[u8]` to implement `TryInto<_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"try using a fully qualified path to specify the expected types","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":2699,"byte_end":2699,"line_start":116,"line_end":116,"column_start":9,"column_end":9,"is_primary":true,"text":[{"text":"        bytes.try_into().map(Ipv6Addr::from).map(Rdata::AAAA)","highlight_start":9,"highlight_end":9}],"label":null,"suggested_replacement":"<&[u8] as TryInto<T>>::try_into(","suggestion_applicability":"HasPlaceholders","expansion":null},{"file_name":"src/main.rs","byte_start":2704,"byte_end":2715,"line_start":116,"line_end":116,"column_start":14,"column_end":25,"is_primary":true,"text":[{"text":"        bytes.try_into().map(Ipv6Addr::from).map(Rdata::AAAA)","highlight_start":14,"highlight_end":25}],"label":null,"suggested_replacement":")","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0283]\u001b[0m\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:116:15\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m116\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        bytes.try_into().map(Ipv6Addr::from).map(Rdata::AAAA)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: multiple `impl`s satisfying `_: TryFrom<&[u8]>` found in the `core` crate:\u001b[0m\n\u001b[0m            - impl<'a, T, N> TryFrom<&'a [T]> for &'a [T; N]\u001b[0m\n\u001b[0m              where the constant `N` has type `usize`;\u001b[0m\n\u001b[0m            - impl<T, N> TryFrom<&[T]> for Simd<T, N>\u001b[0m\n\u001b[0m              where the constant `N` has type `usize`, LaneCount<N>: SupportedLaneCount, T: SimdElement;\u001b[0m\n\u001b[0m            - impl<T, N> TryFrom<&[T]> for [T; N]\u001b[0m\n\u001b[0m              where the constant `N` has type `usize`, T: Copy;\u001b[0m\n\u001b[0m            - impl<T, U> TryFrom<U> for T\u001b[0m\n\u001b[0m              where U: std::convert::Into<T>;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required for `&[u8]` to implement `TryInto<_>`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: try using a fully qualified path to specify the expected types\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m116\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[38;5;10m<&[u8] as TryInto<T>>::try_into(\u001b[0m\u001b[0mbytes\u001b[0m\u001b[0m\u001b[38;5;10m)\u001b[0m\u001b[0m.map(Ipv6Addr::from).map(Rdata::AAAA)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[38;5;10m++++++++++++++++++++++++++++++++\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[38;5;10m~\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 1 previous error","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to 1 previous error\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"For more information about this error, try `rustc --explain E0283`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about this error, try `rustc --explain E0283`.\u001b[0m\n"}
