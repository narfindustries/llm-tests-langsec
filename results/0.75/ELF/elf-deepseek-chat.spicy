module ELF;

import spicy;

public type FileHeader = unit {
    magic: bytes &size=4;
    class: uint8;
    data: uint8;
    version: uint8;
    os_abi: uint8;
    abi_version: uint8;
    padding: bytes &size=7;
    type: uint16;
    machine: uint16;
    version2: uint32;
    entry: uint64;
    phoff: uint64;
    shoff: uint64;
    flags: uint32;
    ehsize: uint16;
    phentsize: uint16;
    phnum: uint16;
    shentsize: uint16;
    shnum: uint16;
    shstrndx: uint16;
};

public type ProgramHeader = unit {
    type: uint32;
    flags: uint32;
    offset: uint64;
    vaddr: uint64;
    paddr: uint64;
    filesz: uint64;
    memsz: uint64;
    align: uint64;
};

public type SectionHeader = unit {
    name: uint32;
    type: uint32;
    flags: uint64;
    addr: uint64;
    offset: uint64;
    size: uint64;
    link: uint32;
    info: uint32;
    addralign: uint64;
    entsize: uint64;
};

public type ELF = unit {
    header: FileHeader;
    program_headers: ProgramHeader[] &until($$.offset + $$.filesz >= $input.size());
    section_headers: SectionHeader[] &until($$.offset + $$.size >= $input.size());
};

on ELF::FileHeader::magic {
    if ( self.magic != b"\x7fELF" )
        throw InvalidELF("Invalid ELF magic number");
}

on ELF::FileHeader::class {
    if ( self.class != 1 && self.class != 2 )
        throw InvalidELF("Invalid ELF class");
}

on ELF::FileHeader::data {
    if ( self.data != 1 && self.data != 2 )
        throw InvalidELF("Invalid ELF data encoding");
}

on ELF::FileHeader::version {
    if ( self.version != 1 )
        throw InvalidELF("Invalid ELF version");
}

on ELF::FileHeader::type {
    if ( self.type < 1 || self.type > 4 )
        throw InvalidELF("Invalid ELF type");
}

on ELF::FileHeader::machine {
    if ( self.machine < 0x03 || self.machine > 0x3E )
        throw InvalidELF("Invalid ELF machine type");
}

on ELF::FileHeader::version2 {
    if ( self.version2 != 1 )
        throw InvalidELF("Invalid ELF version 2");
}

on ELF::FileHeader::ehsize {
    if ( self.ehsize != 64 )
        throw InvalidELF("Invalid ELF header size");
}

on ELF::FileHeader::phentsize {
    if ( self.phentsize != 56 )
        throw InvalidELF("Invalid program header size");
}

on ELF::FileHeader::shentsize {
    if ( self.shentsize != 64 )
        throw InvalidELF("Invalid section header size");
}

on ELF::ProgramHeader::type {
    if ( self.type < 0 || self.type > 6 )
        throw InvalidELF("Invalid program header type");
}

on ELF::SectionHeader::type {
    if ( self.type < 0 || self.type > 11 )
        throw InvalidELF("Invalid section header type");
}

on ELF::SectionHeader::flags {
    if ( self.flags < 0 || self.flags > 0xF )
        throw InvalidELF("Invalid section header flags");
}

on ELF::SectionHeader::addralign {
    if ( self.addralign != 0 && (self.addralign & (self.addralign - 1)) != 0 )
        throw InvalidELF("Invalid section header alignment");
}

on ELF::SectionHeader::entsize {
    if ( self.entsize < 0 )
        throw InvalidELF("Invalid section header entry size");
}

on ELF::ELF::header {
    if ( self.header.class == 1 )
        self.header.entry = uint32(self.header.entry);
    else
        self.header.entry = uint64(self.header.entry);
}

on ELF::ELF::program_headers {
    for ( ph in self.program_headers ) {
        if ( ph.offset + ph.filesz > $input.size() )
            throw InvalidELF("Invalid program header offset or size");
    }
}

on ELF::ELF::section_headers {
    for ( sh in self.section_headers ) {
        if ( sh.offset + sh.size > $input.size() )
            throw InvalidELF("Invalid section header offset or size");
    }
}