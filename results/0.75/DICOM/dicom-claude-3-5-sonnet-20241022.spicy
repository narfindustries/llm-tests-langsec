module DICOM;

public type Message = unit {
    preamble: bytes &size=128;
    prefix: bytes &size=4;
    
    on %done {
        if ( self.prefix != b"DICM" )
            self.set_error("Invalid DICOM prefix");
    }
    
    elements: DataElement[];
};

type DataElement = unit {
    tag_group: uint16;
    tag_element: uint16;
    vr: bytes &size=2 if (self.tag_group != 0xfffe);
    length: uint16 if (self.tag_group != 0xfffe && is_explicit_vr(self.vr));
    length32: uint32 if (self.tag_group != 0xfffe && !is_explicit_vr(self.vr));
    value_length: uint32 if (self.tag_group == 0xfffe);
    
    value: bytes &size=self.get_value_length();
    
    on %done {
        if ( self.tag_group == 0x0002 )
            self.process_meta_element();
    }
};

function is_explicit_vr(vr: bytes): bool {
    return /[A-Z]{2}/ == vr;
}

function get_value_length(de: DataElement): uint32 {
    if ( de.tag_group == 0xfffe )
        return de.value_length;
    if ( is_explicit_vr(de.vr) )
        return de.length;
    return de.length32;
}

on DICOM::Message::%done {
    print "DICOM message parsed";
}

public function process_meta_element(de: DataElement) {
    local tag = (de.tag_group << 16) | de.tag_element;
    switch ( tag ) {
        case 0x00020001: print "File Meta Information Version"; break;
        case 0x00020002: print "Media Storage SOP Class UID"; break;
        case 0x00020003: print "Media Storage SOP Instance UID"; break;
        case 0x00020010: print "Transfer Syntax UID"; break;
        case 0x00020012: print "Implementation Class UID"; break;
        case 0x00020013: print "Implementation Version Name"; break;
        default: print "Other Meta Element"; break;
    }
}