module MQTT;

import spicy;

type MQTTFixedHeader = unit {
    type: uint8 &convert=(self & 0xF0) >> 4;
    flags: uint8 &convert=self & 0x0F;
    remaining_length: bytes &until=b"\x00";
};

type MQTTConnectFlags = unit {
    reserved: uint1;
    clean_session: uint1;
    will_flag: uint1;
    will_qos: uint2;
    will_retain: uint1;
    password_flag: uint1;
    username_flag: uint1;
};

type MQTTConnectPayload = unit {
    client_id: bytes &until=b"\x00";
    will_topic: bytes &until=b"\x00" if self.will_flag;
    will_message: bytes &until=b"\x00" if self.will_flag;
    username: bytes &until=b"\x00" if self.username_flag;
    password: bytes &until=b"\x00" if self.password_flag;
};

type MQTTConnect = unit {
    protocol_name: bytes &until=b"\x00";
    protocol_level: uint8;
    connect_flags: MQTTConnectFlags;
    keep_alive: uint16;
    payload: MQTTConnectPayload;
};

type MQTTConnAck = unit {
    session_present: uint1;
    return_code: uint8;
};

type MQTTSubscribePayload = unit {
    topic: bytes &until=b"\x00";
    qos: uint8;
};

type MQTTSubscribe = unit {
    packet_id: uint16;
    payload: MQTTSubscribePayload[];
};

type MQTTSubAck = unit {
    packet_id: uint16;
    return_codes: uint8[];
};

type MQTTUnsubscribe = unit {
    packet_id: uint16;
    topics: bytes[] &until=b"\x00";
};

type MQTTUnsubAck = unit {
    packet_id: uint16;
};

type MQTTPublish = unit {
    topic: bytes &until=b"\x00";
    packet_id: uint16 if self.qos > 0;
    payload: bytes &eod;
};

type MQTTPubAck = unit {
    packet_id: uint16;
};

type MQTTPubRec = unit {
    packet_id: uint16;
};

type MQTTPubRel = unit {
    packet_id: uint16;
};

type MQTTPubComp = unit {
    packet_id: uint16;
};

type MQTTPacket = unit {
    header: MQTTFixedHeader;
    connect: MQTTConnect if header.type == 1;
    connack: MQTTConnAck if header.type == 2;
    publish: MQTTPublish if header.type == 3;
    puback: MQTTPubAck if header.type == 4;
    pubrec: MQTTPubRec if header.type == 5;
    pubrel: MQTTPubRel if header.type == 6;
    pubcomp: MQTTPubComp if header.type == 7;
    subscribe: MQTTSubscribe if header.type == 8;
    suback: MQTTSubAck if header.type == 9;
    unsubscribe: MQTTUnsubscribe if header.type == 10;
    unsuback: MQTTUnsubAck if header.type == 11;
};

on MQTTPacket::%init {
    self.remaining_length = self.header.remaining_length;
}

on MQTTPacket::%done {
    if ( self.header.type == 3 ) {
        self.publish.payload = self.remaining_length;
    }
}

export MQTTPacket;