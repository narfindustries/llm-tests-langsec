module Modbus;

import spicy;

public type Message = unit {
    function is_request = ($$.is_request);

    function is_response = ($$.is_response);

    function function_code = ($$.function_code);

    header: Header;
    payload: Payload(self.header.function_code) &requires(self.header);

    type Header = unit {
        transaction_id: uint16;
        protocol_id: uint16;
        length: uint16;
        unit_id: uint8;
        function_code: uint8 {
            validate($$ == 1 || $$ == 2 || $$ == 3 || $$ == 4 || $$ == 5 || $$ == 6 || $$ == 15 || $$ == 16);
        };

        var is_request: bool = (self.function_code >= 1 && self.function_code <= 6) || 
                                (self.function_code == 15 || self.function_code == 16);
        var is_response: bool = !self.is_request;
    };

    type Payload = unit(fc: uint8) {
        switch (fc) {
            1, 2 -> read_discrete_inputs_coils(fc);
            3, 4 -> read_holding_input_registers(fc);
            5 -> write_single_coil;
            6 -> write_single_register;
            15 -> write_multiple_coils;
            16 -> write_multiple_registers;
            default -> unknown_payload;
        }

        type read_discrete_inputs_coils = unit(fc: uint8) {
            start_address: uint16;
            quantity: uint16 {
                validate($$ >= 1 && $$ <= 2000);
            }
        }

        type read_holding_input_registers = unit(fc: uint8) {
            start_address: uint16;
            quantity: uint16 {
                validate($$ >= 1 && $$ <= 125);
            }
        }

        type write_single_coil = unit {
            address: uint16;
            value: uint16 {
                validate($$ == 0x0000 || $$ == 0xFF00);
            }
        }

        type write_single_register = unit {
            address: uint16;
            value: uint16;
        }

        type write_multiple_coils = unit {
            start_address: uint16;
            quantity: uint16 {
                validate($$ >= 1 && $$ <= 1968);
            }
            byte_count: uint8;
            coil_values: bytes &length=self.byte_count;
        }

        type write_multiple_registers = unit {
            start_address: uint16;
            quantity: uint16 {
                validate($$ >= 1 && $$ <= 123);
            }
            byte_count: uint8;
            register_values: bytes &length=self.byte_count;
        }

        type unknown_payload = unit {
            data: bytes &eod;
        }
    }
}