#ifndef MODBUS_GEMINI_1_5_FLASH_SPICY
#define MODBUS_GEMINI_1_5_FLASH_SPICY

#include <stdint.h>

// Define Modbus function codes
enum modbus_function_code {
    READ_COILS = 0x01,
    READ_DISCRETE_INPUTS = 0x02,
    READ_HOLDING_REGISTERS = 0x03,
    READ_INPUT_REGISTERS = 0x04,
    WRITE_SINGLE_COIL = 0x05,
    WRITE_SINGLE_REGISTER = 0x06,
    WRITE_MULTIPLE_COILS = 0x0F,
    WRITE_MULTIPLE_REGISTERS = 0x10,
    READ_EXCEPTION_STATUS = 0x07,
    DIAGNOSTIC = 0x08,
    GET_COM_EVENT_COUNTER = 0x0B,
    GET_COM_EVENT_LOG = 0x0C,
    REPORT_SLAVE_ID = 0x11,
    READ_FILE_RECORD = 0x14,
    WRITE_FILE_RECORD = 0x15,
    MASK_WRITE_REGISTER = 0x16,
    READ_WRITE_MULTIPLE_REGISTERS = 0x17,
    READ_FIFO_QUEUE = 0x18,
    READ_DEVICE_IDENTIFICATION = 0x2B
};


// Modbus Request Structure
struct modbus_request {
    uint8_t slave_address;
    uint8_t function_code;
    uint16_t start_address;
    uint16_t quantity;
    uint16_t data[255]; // Adjust size as needed
};

// Modbus Response Structure
struct modbus_response {
    uint8_t slave_address;
    uint8_t function_code;
    uint16_t byte_count;
    uint16_t data[255]; // Adjust size as needed
};


// Function to process Modbus requests
function process_modbus_request(modbus_request req)
{
    // Add your Modbus request processing logic here
    // This should handle different function codes and return a Modbus response
    modbus_response resp;
    resp.slave_address = req.slave_address;
    resp.function_code = req.function_code;
    // ... process request based on function code ...
    return resp;
}


#endif // MODBUS_GEMINI_1_5_FLASH_SPICY
