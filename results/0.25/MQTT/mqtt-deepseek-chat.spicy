module MQTT;

import spicy;

type MQTTFixedHeader = unit {
    type: uint8 &convert=(self & 0xF0) >> 4;
    flags: uint8 &convert=self & 0x0F;
    remaining_length: bytes &until=b"\x00";
};

type MQTTConnectFlags = unit {
    username_flag: bool &convert=(self & 0x80) != 0;
    password_flag: bool &convert=(self & 0x40) != 0;
    will_retain: bool &convert=(self & 0x20) != 0;
    will_qos: uint8 &convert=(self & 0x18) >> 3;
    will_flag: bool &convert=(self & 0x04) != 0;
    clean_session: bool &convert=(self & 0x02) != 0;
    reserved: uint8 &convert=self & 0x01;
};

type MQTTConnect = unit {
    protocol_name: bytes &until=b"\x00";
    protocol_level: uint8;
    connect_flags: MQTTConnectFlags;
    keep_alive: uint16;
    client_id: bytes &until=b"\x00";
    will_topic: bytes &until=b"\x00" if self.connect_flags.will_flag;
    will_message: bytes &until=b"\x00" if self.connect_flags.will_flag;
    username: bytes &until=b"\x00" if self.connect_flags.username_flag;
    password: bytes &until=b"\x00" if self.connect_flags.password_flag;
};

type MQTTConnAck = unit {
    session_present: bool &convert=(self & 0x01) != 0;
    return_code: uint8 &convert=self & 0xFF;
};

type MQTTPublish = unit {
    topic_name: bytes &until=b"\x00";
    packet_id: uint16 if self.fixed_header.type == 3 && (self.fixed_header.flags & 0x06) != 0;
    payload: bytes &size=self.fixed_header.remaining_length - (self.topic_name.size() + 2 + (self.packet_id ? 2 : 0));
};

type MQTTSubscribe = unit {
    packet_id: uint16;
    topic_filters: bytes[] &until=b"\x00";
    qos_levels: uint8[] &size=self.topic_filters.size();
};

type MQTTSubAck = unit {
    packet_id: uint16;
    return_codes: uint8[] &size=self.fixed_header.remaining_length - 2;
};

type MQTTUnsubscribe = unit {
    packet_id: uint16;
    topic_filters: bytes[] &until=b"\x00";
};

type MQTTUnsubAck = unit {
    packet_id: uint16;
};

type MQTTPacket = unit {
    fixed_header: MQTTFixedHeader;
    payload: case (fixed_header.type) of {
        1 => connect: MQTTConnect;
        2 => connack: MQTTConnAck;
        3 => publish: MQTTPublish;
        8 => subscribe: MQTTSubscribe;
        9 => suback: MQTTSubAck;
        10 => unsubscribe: MQTTUnsubscribe;
        11 => unsuback: MQTTUnsubAck;
        * => unknown: bytes &size=fixed_header.remaining_length;
    };
};

on MQTTPacket::%done {
    print self;
}