module MQTT;

import spicy;

public type Packet = unit {
    var fixed_header: FixedHeader;
    var variable_header: VariableHeader;
    var payload: bytes &optional;

    : void {
        self.fixed_header = fixed_header();
        self.variable_header = variable_header(self.fixed_header.packet_type);
    }

    type FixedHeader = unit {
        packet_type: bitfield(8) {
            packet_type: 4 &convert=PacketType($$);
            flags: 4;
        };
        remaining_length: varlen_integer;
    };

    type VariableHeader = unit {
        var protocol_name: bytes &optional;
        var protocol_version: uint8 &optional;
        var connect_flags: bitfield(8) &optional;
        var keep_alive: uint16 &optional;
        var client_id: bytes &optional;

        init(type: PacketType) {
            switch (type) {
                PacketType::CONNECT -> {
                    self.protocol_name = bytes(6) &convert=self.validate_protocol_name;
                    self.protocol_version = uint8;
                    self.connect_flags = bitfield(8);
                    self.keep_alive = uint16;
                    self.client_id = bytes_until_end();
                }
                PacketType::PUBLISH -> {
                    # Topic name for publish
                    self.protocol_name = bytes_until_end();
                }
                # Add other packet type handling as needed
                * -> { }
            }
        }

        function validate_protocol_name(name: bytes) : bytes {
            if (name != b"MQTT") {
                throw "Invalid MQTT protocol name";
            }
            return name;
        }
    };

    enum PacketType : uint8 {
        CONNECT = 1,
        CONNACK = 2,
        PUBLISH = 3,
        PUBACK = 4,
        PUBREC = 5,
        PUBREL = 6,
        PUBCOMP = 7,
        SUBSCRIBE = 8,
        SUBACK = 9,
        UNSUBSCRIBE = 10,
        UNSUBACK = 11,
        PINGREQ = 12,
        PINGRESP = 13,
        DISCONNECT = 14
    };

    function varlen_integer() : uint32 {
        local multiplier = 1;
        local value = 0;
        local encoded_byte: uint8;

        do {
            encoded_byte = uint8;
            value += (encoded_byte & 0x7F) * multiplier;
            multiplier *= 0x80;
        } while ((encoded_byte & 0x80) != 0);

        return value;
    }
};