module NITF;

public type Message = unit {
    file_header: FileHeader;
    image_segments: ImageSegment[];
};

type FileHeader = unit {
    file_profile_name: bytes &size=4;
    file_version: bytes &size=5;
    complexity_level: bytes &size=2;
    standard_type: bytes &size=4;
    originating_station_id: bytes &size=10;
    date_time: bytes &size=14;
    file_title: bytes &size=80;
    security_classification: bytes &size=1;
    copy_number: bytes &size=5;
    num_image_segments: uint16 &byte-order=big;
    
    on %done {
        self.num_image_segments = self.num_image_segments;
    }
};

type ImageSegment = unit {
    im: bytes &size=2;
    image_id: bytes &size=10;
    date_time: bytes &size=14; 
    target_id: bytes &size=17;
    image_title: bytes &size=80;
    security_classification: bytes &size=1;
    encryption: bytes &size=1;
    image_source: bytes &size=42;
    num_sig_rows: uint32 &byte-order=big;
    num_sig_cols: uint32 &byte-order=big;
    pixel_value_type: bytes &size=3;
    image_representation: bytes &size=8;
    image_category: bytes &size=8;
    actual_bits_per_pixel: uint8;
    pixel_justification: bytes &size=1;
    image_coord_system: bytes &size=1;
    image_geo_location: bytes &size=60;
    num_comments: uint32 &byte-order=big;
    image_compression: bytes &size=2;
    compression_rate: uint32 &byte-order=big;
    
    on %done {
        self.num_sig_rows = self.num_sig_rows;
        self.num_sig_cols = self.num_sig_cols;
        self.actual_bits_per_pixel = self.actual_bits_per_pixel;
        self.num_comments = self.num_comments;
        self.compression_rate = self.compression_rate;
    }
};

on NITF::Message::%done {
    print self.file_header.file_profile_name;
    print self.file_header.num_image_segments;
}