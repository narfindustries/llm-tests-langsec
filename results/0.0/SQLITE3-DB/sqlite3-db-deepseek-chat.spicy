module SQLITE3_DB;

import spicy;

type Magic = bytes &size=16 &convert="SQLite format 3\000";

type PageSize = uint16 &convert=4096;

type FileFormatWriteVersion = uint8 &convert=1;

type FileFormatReadVersion = uint8 &convert=1;

type ReservedSpace = uint8 &convert=0;

type MaxEmbeddedPayloadFraction = uint8 &convert=64;

type MinEmbeddedPayloadFraction = uint8 &convert=32;

type LeafPayloadFraction = uint8 &convert=32;

type FileChangeCounter = uint32;

type DatabaseSizeInPages = uint32;

type FirstFreelistPage = uint32;

type NumberOfFreelistPages = uint32;

type SchemaCookie = uint32;

type SchemaFormatNumber = uint32;

type PageCacheSize = uint32;

type LargestRootBtreePage = uint32;

type TextEncoding = uint32 &convert=1;

type UserVersion = uint32;

type IncrementalVacuumMode = uint32;

type ApplicationID = uint32;

type VersionValidFor = uint32;

type SQLiteVersionNumber = uint32;

type Header = struct {
    magic: Magic;
    page_size: PageSize;
    write_version: FileFormatWriteVersion;
    read_version: FileFormatReadVersion;
    reserved_space: ReservedSpace;
    max_payload_fraction: MaxEmbeddedPayloadFraction;
    min_payload_fraction: MinEmbeddedPayloadFraction;
    leaf_payload_fraction: LeafPayloadFraction;
    file_change_counter: FileChangeCounter;
    database_size_in_pages: DatabaseSizeInPages;
    first_freelist_page: FirstFreelistPage;
    number_of_freelist_pages: NumberOfFreelistPages;
    schema_cookie: SchemaCookie;
    schema_format_number: SchemaFormatNumber;
    page_cache_size: PageCacheSize;
    largest_root_btree_page: LargestRootBtreePage;
    text_encoding: TextEncoding;
    user_version: UserVersion;
    incremental_vacuum_mode: IncrementalVacuumMode;
    application_id: ApplicationID;
    version_valid_for: VersionValidFor;
    sqlite_version_number: SQLiteVersionNumber;
};

type SQLite3DB = struct {
    header: Header;
};

on SQLite3DB::%init {
    self.header = Header();
}

on SQLite3DB::%done {
    print self.header;
}