module MQTT;

import spicy;

type MQTTFixedHeader = unit {
    type: uint8 &convert=(self & 0xF0) >> 4;
    flags: uint8 &convert=self & 0x0F;
    remaining_length: bytes &until=b'\x00';
};

type MQTTConnectFlags = unit {
    username_flag: uint8 &convert=(self & 0x80) >> 7;
    password_flag: uint8 &convert=(self & 0x40) >> 6;
    will_retain: uint8 &convert=(self & 0x20) >> 5;
    will_qos: uint8 &convert=(self & 0x18) >> 3;
    will_flag: uint8 &convert=(self & 0x04) >> 2;
    clean_session: uint8 &convert=(self & 0x02) >> 1;
    reserved: uint8 &convert=self & 0x01;
};

type MQTTConnect = unit {
    protocol_name: bytes &until=b'\x00';
    protocol_level: uint8;
    connect_flags: MQTTConnectFlags;
    keep_alive: uint16;
    client_id: bytes &until=b'\x00';
    will_topic: bytes &until=b'\x00' if self.connect_flags.will_flag;
    will_message: bytes &until=b'\x00' if self.connect_flags.will_flag;
    username: bytes &until=b'\x00' if self.connect_flags.username_flag;
    password: bytes &until=b'\x00' if self.connect_flags.password_flag;
};

type MQTTConnAck = unit {
    session_present: uint8 &convert=(self & 0x01);
    return_code: uint8;
};

type MQTTPublish = unit {
    topic_name: bytes &until=b'\x00';
    packet_id: uint16 if self.fixed_header.type == 3 && (self.fixed_header.flags & 0x06) != 0;
    payload: bytes &size=self.fixed_header.remaining_length - (self.topic_name.size() + 2 + (self.packet_id ? 2 : 0));
};

type MQTTSubscribe = unit {
    packet_id: uint16;
    topic_filters: bytes[] &until=$input.size() == 0;
};

type MQTTSubAck = unit {
    packet_id: uint16;
    return_codes: uint8[] &until=$input.size() == 0;
};

type MQTTUnsubscribe = unit {
    packet_id: uint16;
    topic_filters: bytes[] &until=$input.size() == 0;
};

type MQTTUnsubAck = unit {
    packet_id: uint16;
};

type MQTTPacket = unit {
    fixed_header: MQTTFixedHeader;
    payload: case (fixed_header.type) of {
        1 => connect: MQTTConnect;
        2 => connack: MQTTConnAck;
        3 => publish: MQTTPublish;
        8 => subscribe: MQTTSubscribe;
        9 => suback: MQTTSubAck;
        10 => unsubscribe: MQTTUnsubscribe;
        11 => unsuback: MQTTUnsubAck;
        * => unknown: bytes &size=fixed_header.remaining_length;
    };
};

on MQTTPacket::%init {
    print "MQTT Packet detected: Type %d", self.fixed_header.type;
}

on MQTTConnect::%done {
    print "MQTT Connect: Client ID %s", self.client_id;
}

on MQTTConnAck::%done {
    print "MQTT ConnAck: Session Present %d, Return Code %d", self.session_present, self.return_code;
}

on MQTTPublish::%done {
    print "MQTT Publish: Topic %s, Payload %s", self.topic_name, self.payload;
}

on MQTTSubscribe::%done {
    print "MQTT Subscribe: Packet ID %d, Topic Filters %s", self.packet_id, self.topic_filters;
}

on MQTTSubAck::%done {
    print "MQTT SubAck: Packet ID %d, Return Codes %s", self.packet_id, self.return_codes;
}

on MQTTUnsubscribe::%done {
    print "MQTT Unsubscribe: Packet ID %d, Topic Filters %s", self.packet_id, self.topic_filters;
}

on MQTTUnsubAck::%done {
    print "MQTT UnsubAck: Packet ID %d", self.packet_id;
}